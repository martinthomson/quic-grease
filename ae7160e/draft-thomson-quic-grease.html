<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>More Apparent Randomization for QUIC</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
    overscroll-behavior: contain;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 More Grease for QUIC">
<link href="#rfc.section.2" rel="Chapter" title="2 Overall Design">
<link href="#rfc.section.3" rel="Chapter" title="3 Keying">
<link href="#rfc.section.4" rel="Chapter" title="4 Pseudo-Random Permutations">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Remainder">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 XOR">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 FFX Lite">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Predictability">
<link href="#rfc.section.5" rel="Chapter" title="5 Scrambling QUIC Packet Headers">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Scrambling Packet Types">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Scrambling Packet Numbers">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Taking Packet Number Scrambling Further">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="7 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-thomson-quic-grease-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-12-07" />
  <meta name="dct.abstract" content="Options for creating more apparent randomization in the QUIC header are discussed." />
  <meta name="description" content="Options for creating more apparent randomization in the QUIC header are discussed." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">M. Thomson</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Mozilla</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">December 07, 2017</td>
</tr>
<tr>
<td class="left">Expires: June 10, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">More Apparent Randomization for QUIC<br />
  <span class="filename">draft-thomson-quic-grease-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Options for creating more apparent randomization in the QUIC header are discussed.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 10, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#more-grease-for-quic" id="more-grease-for-quic">More Grease for QUIC</a>
</h1>
<p id="rfc.section.1.p.1">The QUIC invariants draft <a href="#INVARIANTS" class="xref">[INVARIANTS]</a> commits QUIC <a href="#QUIC" class="xref">[QUIC]</a> to a small set of traits that are intended to remain stable across all version of QUIC.  However, there are some protocol traits in QUIC version 1 <a href="#QUIC" class="xref">[QUIC]</a> that we do that remain readable.</p>
<p id="rfc.section.1.p.2">This note explores a few options for protecting QUIC against casual inspection by entities other than the endpoints participating in the connection.  These techniques are aimed espectially at making any form of inspection considerably more difficult if the QUIC version of a packet is unknown.</p>
<p id="rfc.section.1.p.3">The intent of applying this protection is to encourage the use of protocol fields that are intentionally designed to be readable to non-participating entities (see also <a href="#SIGNALS" class="xref">[SIGNALS]</a>).  For those fields that can be recovered without access to negotiated cryptographic keys, the intent is to create an incentive to implement version-specific handling rather than to assume that certain properties don&#8217;t change between versions.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#overall-design" id="overall-design">Overall Design</a>
</h1>
<p id="rfc.section.2.p.1">Protocol fields that deploy with predictable values or a limited range of values can ossify.  Ossification is the effect whereby the use of values in a way that is contradictory to established patterns triggers adverse reactions from the network.  Usually, this is a result of middleboxes having developed assumptions about how protocols operate.</p>
<p id="rfc.section.2.p.2">The idea that ossification actively prevents the deployment of modified protocols remains a little contentious in the community.  On the other hand, we have plenty of evidence from TLS deployment to suggest that this happens.  Appendix D.4 of <a href="#TLS13" class="xref">[TLS13]</a> describes an example of ossification and describes the measures that were necessary to counteract it.</p>
<p id="rfc.section.2.p.3">If it is possible to provide a measure of protection against protocol ossification without inordinate expense, then it is the view of at least this author that doing so would have some potential value.  Provided the costs are indeed low enough</p>
<p id="rfc.section.2.p.4">This describes changes to some of the version-specific fields in QUIC version 1 <a href="#QUIC" class="xref">[QUIC]</a>.  Any invariant <a href="#INVARIANTS" class="xref">[INVARIANTS]</a> would not be affected by this change.</p>
<p id="rfc.section.2.p.5">The simplest defense against ossification is to apply a reversible permutation to these values.  A pseudo-random function (PRP) is the obvious choice.  If the key of that function is only known to endpoints, then the values will be readily accessible to endpoints.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#keying" id="keying">Keying</a>
</h1>
<p id="rfc.section.3.p.1">There are two different contexts in which we might consider applying this sort of protection, and the keys we can use differ.</p>
<p id="rfc.section.3.p.2">QUIC already has the tools necessary to derive keys.  Handshake packets use a key that is derived from a combination of a version-specific key (or salt) and the connection ID.  A similar approach could be used here.</p>
<p id="rfc.section.3.p.3">For packets that have packet protection, there are many options available.  The secret used for generating the packet number gap (packet_number_secret) is a candidate.  It might however be better to derive a key from the packet protection secrets (client_pp_secret_&lt;N&gt; or server_pp_secret_&lt;N&gt;).</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#pseudo-random-permutations" id="pseudo-random-permutations">Pseudo-Random Permutations</a>
</h1>
<p id="rfc.section.4.p.1">There are many PRP functions that could apply to this case.  Most come from cryptographic contexts and therefore assume inputs and state spaces that exceed the size of the fields we&#8217;re interested in.  This section presents three options of varying complexity.  It&#8217;s likely that there are many more.</p>
<p id="rfc.section.4.p.2">It is critical to note that these functions are not intended to provide any real confidentiality - you need strong keys and ciphers for that.  None of the functions include any integrity protection either - QUIC already provides integrity protection for its headers.</p>
<p id="rfc.section.4.p.3">These techniques might be used to enable unlinkability in some circumstances.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#remainder" id="remainder">Remainder</a>
</h1>
<p id="rfc.section.4.1.p.1">The first is a simple masking using a remainder remainder operation.  This assumes that there are a limited number of valid values for a given field.  Valid values are either constrained to or mapped to a contiguous range starting from 0.  Then, select a modulus |m| that is greater than the largest value and encryption and decryption are simple:</p>
<pre>
m = max(x) + k
E(x) = x + random() * m
D(x) = x % m
</pre>
<p id="rfc.section.4.1.p.2">The drawback here is that you don&#8217;t get a uniform distribution.  If we use this for the long header and an Initial packet is type 0, then it will never pick anything that isn&#8217;t a multiple of |m|.  Also, the number of values that |k| can assume is small.  The benefit is that this is trivial to implement.  Also, an implementation that chooses not to randomize still produces values that can be understood.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#xor" id="xor">XOR</a>
</h1>
<p id="rfc.section.4.2.p.1">This PRP uses a simple exclusive OR:</p>
<pre>
D(x) = E(x) = x ^ k
</pre>
<p id="rfc.section.4.2.p.2">This method is the easiest to implement.  The drawback here is that |k| is stable and is therefore trivially recovered when multiple messages use the same key.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#ffx-lite" id="ffx-lite">FFX Lite</a>
</h1>
<p><a href="https://csrc.nist.gov/CSRC/media/Projects/Block-Cipher-Techniques/documents/BCM/proposed-modes/ffx/ffx-spec.pdf">FFX</a> is a mode of format-preserving encryption that encrypts values from a space of essentially arbitrary size.  FFX would be ideal apart from one significant drawback: FFX is extremely computationally expensive for smaller values, as it uses more rounds for short values to ensure that it continues to preserve its security margins.</p>
<p id="rfc.section.4.3.p.2">On the other hand, we&#8217;re not looking for any actual security, so we wouldn&#8217;t need to have the obscene number of rounds that FFX depends on for small values (their recommended parameters don&#8217;t include values for 5 bit values, ).</p>
<p id="rfc.section.4.3.p.3">If you make a few choices (cryptographers rarely do this for you, and FFX has the usual cornucopia of tuning parameters), you can produce a set of parameters that makes FFX quite simple and performant.  This is essentially two rounds of FFX with radix=2, P={}, addition=0, method=2, split(n)=floor(n/2), rnds(n)=2, and F(x)=AES(k, x).</p>
<pre>
E(x):
   split = num_bits(x) / 2
   a = x &gt;&gt; split
   b = s &amp; (1 &lt;&lt; split - 1)
   tmp = a ^ AES(k, b)
   result = (tmp &lt;&lt; split) | (b ^ AES(k, tmp))

D(x):
   split = num_bits(x) / 2
   a = x &gt;&gt; split
   b = s &amp; (1 &lt;&lt; split - 1)
   tmp = b ^ AES(k, a)
   result = ((a ^ AES(k, tmp)) &lt;&lt; split) | tmp
</pre>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#predictability" id="predictability">Predictability</a>
</h1>
<p id="rfc.section.4.4.p.1">The XOR and FFX-based methods exhibit properties similar to encryption with AES-ECB mode.  That is, for a given key, the same plaintext will always encrypt to the same ciphertext.</p>
<p id="rfc.section.4.4.p.2">That means that if input values do not vary over time, it will be possible to infer underlying values easily.  The goal is to ensure that the protected values change for each new connection, for which a changing key is sufficient.  As stated, the goal is not to provide confidentiality against a determined attacker, only to defend against a lazy observer.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#scrambling-quic-packet-headers" id="scrambling-quic-packet-headers">Scrambling QUIC Packet Headers</a>
</h1>
<p id="rfc.section.5.p.1">There are two fields in the QUIC header that merit some degree of scrambling: the packet type and the packet number.  The other fields of QUIC packets: invariant bits, connection ID, version, and the message payload are either:</p>
<p></p>

<ul>
<li>invariant and thus important to leave unmodified,</li>
<li>explicitly designed for consumption by middleboxes and thus important to leave unmodified, or</li>
<li>already protected by other means, such as an AEAD <a href="#AEAD" class="xref">[AEAD]</a>.</li>
</ul>
<p id="rfc.section.5.p.3">It&#8217;s possible that this technique could be applied to invariant fields, but that is likely to have less immediate utility.  Worse, it would commit every future version of the protocol to employ the same technique.  Limiting this to version-specific fields allows the technique to improve with successive protocol versions.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#scrambling-packet-types" id="scrambling-packet-types">Scrambling Packet Types</a>
</h1>
<p id="rfc.section.5.1.p.1">We have two values here, a 7-bit value that is used for the long header, and a 5-bit value that is used for the short header.  It is possible that the KEY_PHASE bit in the short header could also be covered.</p>
<p id="rfc.section.5.1.p.2">Any of the described methods could work to obscure these fields.  The remainder method would however degrade as new packet types are defined, though the current set of types is very small.</p>
<p id="rfc.section.5.1.p.3">The cost of scrambling for packet types is that the entire space of values is then used, which could make multiplexing with realtime protocols more challenging.  However, it is possible that those protocols could use their out-of-band negotiation to influence the scrambling.  For instance, they might mandate the use of a connection ID from a set of values that produce values that are compatible with the multiplexing scheme in use (determining such a value would be easy).</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#scrambling-packet-numbers" id="scrambling-packet-numbers">Scrambling Packet Numbers</a>
</h1>
<p id="rfc.section.5.2.p.1">Scrambling packet numbers is relatively straightforward to apply.  The remainder method doesn&#8217;t work here, though the XOR and FFX-based techniques both work well.</p>
<p id="rfc.section.5.2.p.2">The cost of scrambling the packet number is that it would make it more difficult to use packet numbers to support the use of other features, like the heuristics necessary to use the spin bit in the presence of loss and reordering.</p>
<p id="rfc.section.5.2.p.3">If a variable-length integer is used to represent a packet number and FFX is chosen, the length would need to be separately scrambled.  That suggests that retaining the packet number length in the type field is desirable if FFX is chosen.</p>
<p id="rfc.section.5.2.p.4">For a packet number, the XOR-based technique would not provide any appreciable barrier to recovery of the underlying value.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#taking-packet-number-scrambling-further" id="taking-packet-number-scrambling-further">Taking Packet Number Scrambling Further</a>
</h1>
<p id="rfc.section.5.2.1.p.1">If packet numbers are scrambled, it is possible to use that scrambling instead of both initial packet number randomization and the packet number gap.</p>
<p id="rfc.section.5.2.1.p.2">For the initial packet number, scrambling would be sufficient to ensure that the packet number field could contain all possible values.  That removes the need to reserve 1024 values to avoid overflow of the 32-bit space before a peer receives the initial value.  Packet numbers would always start at 0, but the wire encoding would be encoded.</p>
<p id="rfc.section.5.2.1.p.3">For the packet number gap, if the key calculation takes connection ID as input, the need for a packet number gap is eliminated.  Switching to a new connection ID would cause packet numbers to become unlinkable with previous ones.  Deriving the per-connection-ID key with HKDF would ensure that even with a simple XOR, the two keys can&#8217;t be correlated.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This section exists so that I can submit a draft without being badgered about this.  There are almost certainly security concerns here, but I don&#8217;t care.  This draft is a throwaway.</p>
<h1 id="rfc.references">
<a href="#rfc.references">7.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="AEAD">[AEAD]</b></td>
<td class="top">
<a>McGrew, D.</a>, "<a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="INVARIANTS">[INVARIANTS]</b></td>
<td class="top">
<a>Thomson, M.</a>, "<a href="https://tools.ietf.org/html/draft-thomson-quic-invariants-00">Version-Independent Properties of QUIC</a>", Internet-Draft draft-thomson-quic-invariants-00, November 2017.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC">[QUIC]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-08">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-08, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SIGNALS">[SIGNALS]</b></td>
<td class="top">
<a>Hardie, T.</a>, "<a href="https://tools.ietf.org/html/draft-hardie-path-signals-02">Path signals</a>", Internet-Draft draft-hardie-path-signals-02, November 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TLS13">[TLS13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-22">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-22, November 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div>
  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">More Grease for QUIC</a>
</li>
<li>2.   <a href="#rfc.section.2">Overall Design</a>
</li>
<li>3.   <a href="#rfc.section.3">Keying</a>
</li>
<li>4.   <a href="#rfc.section.4">Pseudo-Random Permutations</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Remainder</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">XOR</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">FFX Lite</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Predictability</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Scrambling QUIC Packet Headers</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Scrambling Packet Types</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Scrambling Packet Numbers</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Taking Packet Number Scrambling Further</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.references">Informative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/martinthomson/quic-grease">Fork me on GitHub</a></div></div>
</body>
</html>
